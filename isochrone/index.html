<!DOCTYPE html>
<html>

<head>
    <!--  Include leaflet javascript and css -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.3/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.0.3/dist/leaflet-src.js" crossorigin=""></script>

    <!--  Include targomo core -->
    <script src="https://releases.targomo.com/core/latest.min.js"></script>
    <script src="https://releases.targomo.com/leaflet/latest.min.js"></script>

     <script src="spin/dist/spin.min.js" charset="utf-8"></script>
    <script src="leaflet.spin.min.js" charset="utf-8"></script>

<!-- Load Esri Leaflet from CDN -->
    <script src="https://unpkg.com/esri-leaflet@2.3.0/dist/esri-leaflet.js"
    integrity="sha512-1tScwpjXwwnm6tTva0l0/ZgM3rYNbdyMj5q6RSQMbNX6EUMhYDE3pMRGZaT41zHEvLoWEK7qFEJmZDOoDMU7/Q=="
    crossorigin=""></script>

    <link rel="stylesheet" href="https://unpkg.com/esri-leaflet-geocoder@2.2.14/dist/esri-leaflet-geocoder.css"
    integrity="sha512-v5YmWLm8KqAAmg5808pETiccEohtt8rPVMGQ1jA6jqkWVydV5Cuz3nJ9fQ7ittSxvuqsvI9RSGfVoKPaAJZ/AQ=="
    crossorigin="">
  <script src="https://unpkg.com/esri-leaflet-geocoder@2.2.14/dist/esri-leaflet-geocoder.js"
    integrity="sha512-uK5jVwR81KVTGe8KpJa1QIN4n60TsSV8+DPbL5wWlYQvb0/nYNgSOg9dZG6ViQhwx/gaMszuWllTemL+K+IXjg=="
    crossorigin=""></script>

    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
<script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

    <style>
        body, html {
            margin: 0;
            width: 100%;
            height: 100%;
        }
        #map {
            width: 100%;
            height: 100%;

        }
        .button-group {
            position: absolute;
            right: 10px;
            top: 10px;
            z-index: 1000;
            box-shadow: 0 1px 5px rgba(0, 0, 0, .4);
            background-color: rgba(255, 255, 255, 1);
        }
        .button {
            font-family: sans-serif;
            text-transform: uppercase;
            color: #666;
            cursor: pointer;
            padding: 10px 10px 8px 10px;
            display: inline-block;
            font-size: 14px;
        }
        .button:hover {
            background-color: #EEE;
        }
        .button.active {
            color: #003E7A;
        }
        #btn-spin {
         position: absolute;
        left: 200px;
        z-index: 10;
        font-size: 1.5em;
        }
        #export {
            position: absolute;
            top:50px;
            right:0px;
            z-index:100;
            background-color: rgba(255, 255, 255, 1);
            box-shadow: 0 1px 5px rgba(0, 0, 0, .4);
            color:#666;
            padding:10px 10px 8px 10px;
            font-family: sans-serif;
            text-transform: uppercase;
            cursor: pointer;
            font-size:14px;
            text-decoration:none;
        }
        #export {
            top:40px;
        }
        #request {
            position: absolute;
            top:50px;
            right:0px;
            z-index:100;
            background-color: rgba(255, 255, 255, 1);
            box-shadow: 0 1px 5px rgba(0, 0, 0, .4);
            color:#666;
            padding:10px 10px 8px 10px;
            font-family: sans-serif;
            text-transform: uppercase;
            cursor: pointer;
            font-size:14px;
            text-decoration:none;
        }
        #request {
            top:40px;
        }
        .slidecontainer {
          width: 50%; /* Width of the outside container */
          z-index: 100;
          box-shadow: 0 1px 5px rgba(0, 0, 0, .4);
          background-color: rgba(255, 255, 255, 1);
          position: absolute;
            right: 25%;
            bottom: 10px;
            z-index: 1000;
        }

        /* The slider itself */
        .slider {
          -webkit-appearance: none;  /* Override default CSS styles */
          width: 95%;
          position: absolute;
          right: 2%;
          top: 10px; /* Full-width */
          height: 25px; /* Specified height */
          background: #d3d3d3; /* Grey background */
          outline: none; /* Remove outline */
          opacity: 1; /* Set transparency (for mouse-over effects on hover) */
          -webkit-transition: .2s; /* 0.2 seconds transition on hover */
          transition: opacity .2s;
        }

        /* Mouse-over effects */
        .slider:hover {
          opacity: 1; /* Fully shown on mouse-over */
        }

        /* The slider handle (use -webkit- (Chrome, Opera, Safari, Edge) and -moz- (Firefox) to override default look) */ 
        .slider::-webkit-slider-thumb {
          -webkit-appearance: none; /* Override default look */
          appearance: none;
          width: 25px; /* Set a specific slider handle width */
          height: 25px; /* Slider handle height */
          background: #003E7A; /* Green background */
          cursor: pointer; /* Cursor on hover */
        }

        .slider::-moz-range-thumb {
          width: 25px; /* Set a specific slider handle width */
          height: 25px; /* Slider handle height */
          background: #4CAF50; /* Green background */
          cursor: pointer; /* Cursor on hover */
        }
         .minute {
            font-family: sans-serif;
            text-transform: uppercase;
            color: #003E7A;
            cursor: pointer;
            padding: 30px 10px 0px 10px;
            display: inline-block;
            font-size: 14px;
        }
        .logo {
            position: absolute;
            bottom:20px;
            right:10px;
            z-index:400;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="map"></div>
<script>
let medium = 'transit';
</script>

<div class="slidecontainer">
    <center><input type="range" min="1" max="30" value="5" class="slider" id="myRange">
    <p style ="margin-bottom: 6px;"><span id="demo" class = "minute"> min</span></p></center>
</div>
<script>
    var slider = document.getElementById("myRange");
    var output = document.getElementById("demo");
    output.innerHTML = slider.value + ' min'; // Display the default slider value
    travelTimes = [slider.value*60];

    slider.oninput = function() {
          output.innerHTML = this.value + ' min';
          travelTimes = [this.value*60]
            setData(medium);
    }
</script>

    <div id="selectionBar" class="button-group">
        <div id="btn-walk" onclick="setData(&apos;walk&apos;); medium = 'walk'" class="button">walk</div>
        <div id="btn-bike" onclick="setData(&apos;bike&apos;); medium = 'bike'" class="button active">bike</div>
        <div id="btn-car" onclick="setData(&apos;car&apos;); medium = 'car'"" class="button">car</div>
        <div id="btn-transit" onclick="setData(&apos;transit&apos;); medium = 'transit'"" class="button">transit</div>
        <a href='#' id='export'>Export Features</a>
        <!-- <div id="request" onclick="showPop(convertedStudy2)" class="button">Calcuate Demographics</div> -->
      <!-- fetchAPI(); -->  
    </div>
        <img src="logo.png" class="logo">


    <script>

        //slider
        // create targomo client
        const client = new tgm.TargomoClient('northamerica', '1AVFMMCTC28HZN1PPSN7JAG');
        // define the basemap
        const colorModes = [
            {text: 'Standard', value:"standard", data: {60: '#11FF00', 120: '#22FF00', 180: '#33FF00', 240: '#44FF00', 300: '#55FF00', 360: '#66FF00', 420: '#77FF00', 480: '#88FF00', 540: '#99FF00', 600: '#AAFF00', 660: '#BBFF00', 720: '#CCFF00', 780: '#DDFF00', 840: '#EEFF00', 900: '#FFFF00', 960: '#FEEE00', 1020: '#FEDD00', 1080: '#FECC00', 1140: '#FDBB00', 1200: '#FDAA00', 1260: '#FD9900', 1320: '#FC8800', 1380: '#FC7700', 1440: '#FC6600', 1500: '#FB5500', 1560: '#FB4400', 1620: '#FB3300', 1680: '#FA2200', 1740: '#FA1100', 1800: '#FA0000'}},
        ];
        const tileLayer = L.tileLayer('https://api.mapbox.com/styles/v1/kpclyne/cjy9ts3mh0y9j1do9uss5fz8o/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1Ijoia3BjbHluZSIsImEiOiJjanN3MzlpY2EwZGpjM3lsaGNhb3NqY3JmIn0._sGjIhmL5Xt08WIMWRsSsg');
        // Coordinates to center the map
        const center = [40.719040, -74.008927];

        // define the map
        var map = L.map('map', {
            layers: [tileLayer],
            scrollWheelZoom: true
        }).setView(center, 12);
        
        var markerimage = L.icon({
            iconUrl: 'bluemarker.png',
            shadowUrl: 'markershadow.png',

            iconSize:     [35.5, 46], // size of the icon
            shadowSize:   [36, 16], // size of the shadow
            iconAnchor:   [18.5, 43], // point of the icon which will correspond to marker's location
            shadowAnchor: [10, 10],  // the same for the shadow
            popupAnchor:  [0, -43] // point from which the popup should open relative to the iconAnchor
        });

        var geocoder = L.Control.geocoder({
            defaultMarkGeocode: false,
            position: "topleft"
        })
            .on('markgeocode', function(e) {
                var lat = e.geocode.center.lat;
                var lng = e.geocode.center.lng;
                source = {id: source.id, lat: lat, lng: lng};
                if (marker != undefined) {
                  map.removeLayer(marker);
                };
                marker = L.marker((e.geocode.center), {icon: markerimage}).addTo(map);
                async function setData(medium) {
                const selector = `btn-${medium}`;
                map.spin(false);

                // you need to define some options for the polygon service
                const options = {
                travelType: medium,
                travelEdgeWeights: travelTimes,
                maxEdgeWeight: 1800,
                edgeWeight: 'time',
                transitMaxTransfers: medium === 'transit' ? 5 : null,
                serializer: 'json',
                rushHour: medium === 'car' ? true : null,
                 };
                const options2 = {
                travelType: medium,
                travelEdgeWeights: travelTimes,
                maxEdgeWeight: 1800,
                edgeWeight: 'time',
                transitMaxTransfers: medium === 'transit' ? 5 : null,
                serializer: 'geojson',
                rushHour: medium === 'car' ? true : null,
                buffer: '0.005',
                };

                // get the polygons
                const polygons = await client.polygons.fetch([source], options);
                const polygons2 = await client.polygons.fetch([source], options2);
                var convertedData = 'text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(polygons2));
                geom = polygons2.features[0].geometry.coordinates[0];
                geom2 = polygons2.features[0].geometry.coordinates;
                console.log(geom2);
                convertedStudy = encodeURIComponent(JSON.stringify(geom));
                convertedStudy2 = encodeURIComponent(JSON.stringify(geom2));
                // add polygons to overlay
                setTimeout(function () {
                    polygonOverlayLayer.setData(polygons);
                    map.spin(false);
                }, 200);
                // calculate bounding box for polygons
                const bounds = polygons.getMaxBounds();
                // zoom to the polygon bounds
                map.fitBounds(new L.latLngBounds(bounds.northEast, bounds.southWest));
                // get the geojson
                geocodeService.reverse().latlng(e.geocode.center).run(function(error, result){
                geo = result.address.City;
                name = today + '_' + geo + '_' + output.innerHTML + '_' + medium;
                newname = name.toUpperCase()
                console.log(newname);
                document.getElementById('export').onclick = function(e) {
                document.getElementById('export').setAttribute('href', 'data:' + convertedData);
                document.getElementById('export').setAttribute('download', newname +'.geojson');

            } 
            });

        }
                setData(medium);
            })
            .addTo(map);
        // set the attribution
        const attributionText = `<a href='https://www.hraadvisors.com' target='_blank'>&copy; Kevin Clyne</a> <a href='http://mapbox.com/' target='_blank'>&copy; MapBox</a> <a href='https://targomo.com/developers/attribution/' target='_blank'>&copy; Targomo</a>`
        map.attributionControl.addAttribution(attributionText);
        var geocodeService = L.esri.Geocoding.geocodeService();
        var today = new Date();
        var dd = today.getDate();
        var mm = today.getMonth() + 1; //January is 0!

        var yyyy = today.getFullYear();
        var yy = (yyyy - 2000);
        if (dd < 10) {
         dd = '0' + dd;
        } 
        if (mm < 10) {
        mm = '0' + mm;
        } 

        var today = yy + mm + dd;
        // const travelTimes = [300, 600, 900, 1200, 1500, 1800];
        let source = {id: 0, lat: 40.719040, lng: -74.008927};
        let marker = L.marker([40.719040, -74.008927], {icon: markerimage}).addTo(map);
        const polygonOverlayLayer = new tgm.leaflet.TgmLeafletPolygonOverlay({ strokeWidth: 20 });
        polygonOverlayLayer.addTo(map);
        polygonOverlayLayer.setColors(colorModes[0].data)
        
        // draw marker and add source
        function onMapClick(e) {
            var lat = e.latlng.lat;
            var lng = e.latlng.lng;
            source = {id: source.id, lat: lat, lng: lng};
            if (marker != undefined) {
              map.removeLayer(marker);
            };
            marker = L.marker((e.latlng), {icon: markerimage}).addTo(map);
            async function setData(medium) {
                const selector = `btn-${medium}`;
                map.spin(true);

                // you need to define some options for the polygon service
                const options = {
                travelType: medium,
                travelEdgeWeights: travelTimes,
                maxEdgeWeight: 1800,
                edgeWeight: 'time',
                transitMaxTransfers: medium === 'transit' ? 5 : null,
                serializer: 'json',
                rushHour: medium === 'car' ? true : null,
                 };
                const options2 = {
                travelType: medium,
                travelEdgeWeights: travelTimes,
                maxEdgeWeight: 1800,
                edgeWeight: 'time',
                transitMaxTransfers: medium === 'transit' ? 5 : null,
                serializer: 'geojson',
                rushHour: medium === 'car' ? true : null,
                buffer: '0.005',
                };

                // get the polygons
                const polygons = await client.polygons.fetch([source], options);
                const polygons2 = await client.polygons.fetch([source], options2);
                var convertedData = 'text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(polygons2));
                geom = polygons2.features[0].geometry.coordinates[0];
                geom2 = polygons2.features[0].geometry.coordinates;
                console.log(geom2);
                convertedStudy = encodeURIComponent(JSON.stringify(geom));
                convertedStudy2 = encodeURIComponent(JSON.stringify(geom2));
                // add polygons to overlay
                setTimeout(function () {
                    polygonOverlayLayer.setData(polygons);
                    map.spin(false);
                }, 200);
                // calculate bounding box for polygons
                const bounds = polygons.getMaxBounds();
                // zoom to the polygon bounds
                map.fitBounds(new L.latLngBounds(bounds.northEast, bounds.southWest));
                // get the geojson
                geocodeService.reverse().latlng(e.latlng).run(function(error, result){
                geo = result.address.City;
                name = today + '_' + geo + '_' + output.innerHTML + '_' + medium;
                newname = name.toUpperCase()
                console.log(newname);
                document.getElementById('export').onclick = function(e) {
                document.getElementById('export').setAttribute('href', 'data:' + convertedData);
                document.getElementById('export').setAttribute('download', newname +'.geojson');

            } 
            });

        }
            setData(medium);
        }

        async function setData(mode) {
                const selector = `btn-${mode}`;
                map.spin(true);
                document.getElementsByClassName('active')[0].classList.remove('active');
                document.getElementById(selector).classList.add('active');

                // you need to define some options for the polygon service
                const options = {
                travelType: mode,
                travelEdgeWeights: travelTimes,
                maxEdgeWeight: 1800,
                edgeWeight: 'time',
                transitMaxTransfers: mode === 'transit' ? 5 : null,
                serializer: 'json',
                rushHour: mode === 'car' ? true : null,
                 };
                const options2 = {
                travelType: mode,
                travelEdgeWeights: travelTimes,
                maxEdgeWeight: 1800,
                edgeWeight: 'time',
                transitMaxTransfers: mode === 'transit' ? 5 : null,
                serializer: 'geojson',
                rushHour: mode === 'car' ? true : null,
                buffer: '0.005',
                };

                // get the polygons
                const polygons = await client.polygons.fetch([source], options);
                const polygons2 = await client.polygons.fetch([source], options2);
                var convertedData = 'text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(polygons2));
                geom = polygons2.features[0].geometry.coordinates[0];
                geom2 = polygons2.features[0].geometry.coordinates;
                console.log(geom2);
                convertedStudy = encodeURIComponent(JSON.stringify(geom));
                convertedStudy2 = encodeURIComponent(JSON.stringify(geom2));
                // add polygons to overlay
                setTimeout(function () {
                    polygonOverlayLayer.setData(polygons);
                    map.spin(false);
                }, 200);
                // calculate bounding box for polygons
                const bounds = polygons.getMaxBounds();
                // zoom to the polygon bounds
                map.fitBounds(new L.latLngBounds(bounds.northEast, bounds.southWest));
                // get the geojson
                geocodeService.reverse().latlng(source).run(function(error, result){
                geo = result.address.City;
                name = today + '_' + geo + '_' + output.innerHTML + '_' + mode;
                newname = name.toUpperCase()
                document.getElementById('export').onclick = function(e) {
                document.getElementById('export').setAttribute('href', 'data:' + convertedData);
                document.getElementById('export').setAttribute('download', newname +'.geojson');
            } 
            });

            }
        var token = 'DyQ1CBflybQI_4WdJzCz1noCVqCajMwsmtODv9V3ouNXZh5rxlVdN28ZthEkYEJS2eEoXLdPYQttKlzTL_aM6fhhZbiC9xkHfVXp6GhFiaync4rg_2os2xhadMH_piGs19yr87tQjZaE0nHgED_7XkhH-XdspHx9wHqJdaTkZfqe-OQTwvplmnlz0GAiYFxELcc-St9ub8IgAHYqx6_GYg..';
        async function fetchAPI(){
                    response2 = await fetch('https://geoenrich.arcgis.com/arcgis/rest/services/World/geoenrichmentserver/GeoEnrichment/enrich?StudyAreas=[{"geometry":{"rings":'+convertedStudy2+',"spatialReference":{"wkid":3857}}}]&StudyAreasOptions={"GeometryType":"esriGeometryPolygon","SpatialRelationship":"esriSpatialRelIntersects"}&dataCollections=["KeyUSFacts"]&returngeometry=true&f=pjson&token=' + token);
                    json2 = await response2.json();
                    console.log(json2);
                    marker.bindPopup("<b>Population: </b>" + json2.results[0].value.FeatureSet[0].features[0].attributes.TOTPOP_CY ).openPopup();
                }
        setData('transit');

        // Blegh

        function showPop(str) {
          var xhttp;    
          xhttp = new XMLHttpRequest();
          xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
              var ESRI = JSON.parse(this.responseText);
              // console.log(str);
              console.log(ESRI.results[0].value.FeatureSet[0].features[0].attributes.TOTPOP_CY);
            }
          };
          xhttp.open("GET", 'https://geoenrich.arcgis.com/arcgis/rest/services/World/geoenrichmentserver/GeoEnrichment/enrich?StudyAreas=[{"geometry":{"rings":'+str+',"spatialReference":{"wkid":3857}}}]&StudyAreasOptions={"GeometryType":"esriGeometryPolygon","SpatialRelationship":"esriSpatialRelIntersects"}&dataCollections=["KeyUSFacts"]&returngeometry=true&f=pjson&token=' + token, true);
          xhttp.send();
        }

        map.on('click', onMapClick);

        </script>
</body>

</html>
        
